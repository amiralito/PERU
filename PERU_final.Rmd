---
title: "PERU paper final script"
output:
  pdf_document: default
  html_document:
    df_print: paged
Author: AmirAli Toghani
---

Required Packages:

```{r}

```

After downloading the data from ./proteomes unzip it using the following command (mac OS) or other decompressing programs:

```{bash}

cd /path/to/proteomes/

gunzip *.gz
```

# Part one: Database preparation

```{r}
# load the requierd packages
library(Biostrings)
library(tidyverse)
library(readr)

# set the path to the directory containing the proteome FASTA files
fasta_dir <- "/path/to/the/proteoms/"

# get a list of all the file names in the directory
fasta_files <- list.files(fasta_dir, pattern = ".fasta", recursive = TRUE)

# use lapply() to read in each file and store the sequences as a DNAStringSet object
fasta_seqs <- lapply(fasta_files, function(x) {
  # Read in the fasta file
  seqs <- readAAStringSet(file.path(fasta_dir, x))
  
  # Add the file name as metadata to each sequence
  mcols(seqs)$file_name <- x
  
  # Return the AAStringSet object
  seqs
})

# combine all the sequences into a single AAStringSet object
SolDB <- do.call(c, fasta_seqs)
SolDB@ranges@NAMES <- sub(" .*", "", SolDB@ranges@NAMES) # protein name clean-up

# metadata dataframe
SolDB_meta <- data.frame(ID = SolDB@ranges@NAMES,
                         genome = SolDB@elementMetadata@listData)
SolDB_meta$file_name <- gsub("*.fasta", "", SolDB_meta$file_name) # file name clean-up

# write the DB
writeXStringSet(SolDB, "/path/to/your/directory/SolDB.fasta")




# metadata compilation

# import the genome metadata information file (table S2)
Genome_data <- read_csv("/path/to/table_S2.csv") # import genome metadata

genome_meta <- Genome_data[,c(1,  # organism
                              3,  # file_name
                              19, # Genus
                              23, # Species
                              24)] # Subspcies

# a new columns with simple scientific names
genome_meta$SciName <- paste(genome_meta$Genus, genome_meta$Species, sep = " ") %>% 
  str_replace_all(pattern = "NA", replacement = " ")

# optional: export the metadata
write_csv(genome_meta, "/path/to/your/directory/genome_meta.csv")

# merge the database metadata and genome metadata based on file names to have everything all together
SolDB_metadata <- SolDB_meta %>% left_join(genome_meta, by = "file_name")

write.csv(SolDB_metadata, "/path/to/your/directory/SolDB_metadata.csv") # export it if you like

```

# Part two: Search for PK and LRR containing proteins

1.  Search for proteins containing PK domain using hmmsearch

```{bash}

# first search for Protein Kinase domain by searching the dataset for Pfam PF00069 hmm profile using hmmsearch and following options
hmmsearch -o PF00069.out --tblout PF00069_tbl.out --domtblout PF00069_domtbl.out --max PF00069.hmm SolDB.fasta 

```

-   Import and process the hmmsearch output

```{r}
library(Biostrings)
library(tidyverse)
library(readr)

# import the PK hmmsearch output
PK_tbl <- read_table("/path/to/PF00069_tbl.out",
                     col_names = FALSE, col_types = cols(X19 = col_skip()), 
                     skip = 3) %>% head(-10)


PK_scores <- PK_tbl[,c(1,5,6,7)] %>% setNames(c("ID","E-Value","score","bias")) # dataframe with only scores and e-values
PK_scores_filtered <- PK_scores[PK_scores$`E-Value` < 0.01,] # remove anything below the e-value threshold of 0.01

PK_seq <- SolDB_geneious[PK_scores_filtered$ID] # PK containing sequences


# keep onky the sequences with one kinase domain
# import the domain table output from hmmsearch
PK_domtbl <- read_table("/path/to/PF00069_domtbl.out",
                        col_names = FALSE, col_types = cols(X19 = col_skip()), 
                        skip = 3) %>% head(-10)



PK_domtbl_filtered <- filter(PK_domtbl, PK_domtbl$X11 == 1) # keep only the ones with one PK domain
PK_domtbl_filtered <- filter(PK_domtbl_filtered, PK_domtbl_filtered$X7 < 0.01) # remove anything below the e-value threshold of 0.01

# refine the PK table and export it for next step
PK_filtered <- PK_scores_filtered[PK_scores_filtered$ID %in% PK_domtbl_filtered$X1,]
PK_filtered_seq <- PK_seq[PK_filtered$ID]

write_csv(PK_filtered, "/path/to/PK_filtered.csv")
writeXStringSet(PK_filtered_seq, "/path/to/PK_filtered.fasta")

# extract the PK domains only. This will be used for phylogenetic analysis
PK_domain_seq <- subseq(PK_filtered_seq, start = PK_domtbl_filtered$X20, end = PK_domtbl_filtered$X21)

```

2.  Search for presence of LRR domain in the PK containing sequneces

```{bash}

# LRR_1 (Pfam PF00560)
hmmsearch -o PF00560.out --tblout PF00560_tbl.out --domtblout PF00560_domtbl.out --max PF00560.hmm PK_filtered.fasta

# LRRNT_2 (Pfam PF08263)
hmmsearch -o PF08263.out --tblout PF08263_tbl.out --domtblout PF08263_domtbl.out --max PF08263.hmm PK_filtered.fasta

# LRR_6 (Pfam PF13516)
hmmsearch -o PF13516.out --tblout PF13516_tbl.out --domtblout PF13516_domtbl.out --max PF13516.hmm PK_filtered.fasta

# LRR_8 (Pfam PF13855)
hmmsearch -o PF13855.out --tblout PF13855_tbl.out --domtblout PF13855_domtbl.out --max PF13855.hmm PK_filtered.fasta

```

-   Import and process the hmmsearch output

```{r}
library(Biostrings)
library(tidyverse)
library(readr)

# LRR1
LRR1_tbl <- read_table("/path/to/PF00560_tbl.out",
                        col_names = FALSE, col_types = cols(X19 = col_skip()), 
                        skip = 3) %>% head(-10)
LRR1_tbl <- filter(LRR1_tbl, LRR1_tbl$X5 < 0.01) # remove anything below the e-value threshold of 0.01
LRR1 <- LRR1_tbl$X1 %>% as.data.frame() # keep only the ids

#LRR6
LRR6_tbl <- read_table("/path/to/PF13516_tbl.out",
                       col_names = FALSE, col_types = cols(X19 = col_skip()), 
                       skip = 3) %>% head(-10)
LRR6_tbl <- filter(LRR6_tbl, LRR6_tbl$X5 < 0.01) # remove anything below the e-value threshold of 0.01
LRR6 <- LRR6_tbl$X1 %>% as.data.frame() # keep only the ids

# LRR8
LRR8_tbl <- read_table("/path/to/PF13855_tbl.out",
                       col_names = FALSE, col_types = cols(X19 = col_skip()), 
                       skip = 3) %>% head(-10)
LRR8_tbl <- filter(LRR8_tbl, LRR8_tbl$X5 < 0.01) # remove anything below the e-value threshold of 0.01
LRR8 <- LRR8_tbl$X1 %>% as.data.frame() # keep only the ids

#LRRNT2
LRRNT2_tbl <- read_table("/path/to/PF08263_tbl.out",
                      col_names = FALSE, col_types = cols(X19 = col_skip()), 
                      skip = 3) %>% head(-10)
LRRNT2_tbl <- filter(LRRNT2_tbl, LRRNT2_tbl$X5 < 0.01) # remove anything below the e-value threshold of 0.01
LRRNT2 <- LRRNT2_tbl$X1 %>% as.data.frame() # keep only the ids

# merge all LRR containing proteins
LRR <- Reduce(function(x,y) merge(x,y, by = ".", all = TRUE), list(LRR1,LRR6,LRR8,LRRNT2)) # merge all LRR containing proteins

names(LRR) <- "ID"

# subset the PK domain of the remaining proteins for alignment and phylogenetic analysis
LRR_seq <- PK_filtered_seq[LRR$ID]
LRR_PK_seq <- PK_domain_seq[LRR$ID]

writeXStringSet(LRR_seq, "/path/to/LRR.fasta") # full-length
writeXStringSet(LRR_PK_seq, "/path/to/LRR_PKD.fasta") # PK domain only
```

# Part three: Phylogenetic tree construction and analyses

Upon extraction of the LRR-RK sequences, their PK domains were aligned with the PK domains of reference LRR-RKs utilizing MAFFT. The resulting alignment was subsequently employed to construct phylogenetic trees via FastTree. This was done for every set of sequence deposited for the supplementary material including LRR-RKs, Subgroup XII, PERU, and FLS2.

To extract the PERU clade, multiple iterations of alignment and tree construction was done in order to reach desired resolution. For this purpose, each time a well-supported major branch was chosen, extracted and realigned to make a new tree. This was repeated until a good resolution to compare PERU with its closely related sequences was obtained (average pairwise alignment \~77%; PK domain only).

Furthermore, full-length sequences for the final clade was extracted for more concise alignment and a better overview of phylogenetic relations for both PERU and FLS2 clades.

```{bash}

# alignment
mafft --anysymbol sequence.fasta > alignment.afa

# tree construction
FastTree alignment.afa > tree.newick
```

# Part Four: Data Visualization

After extracting the PERU and FLS2 phylogenetic clades, the heatmaps were produced in R using the following script. The phylogenetic trees were visualized by iTOL and then assembled together with the heatmaps in Adobe Photoshop.

-   raw data preparation:

```{r}
library(Biostrings)
library(tidyverse)
library(readr)

# import the tip labels from the phylogenetic trees made from previous steps
# import the tip labels extracted from the tree in the same order. this was done using TreeViewer software

DM_hm_nr <- read_table("/path/to/PERU.txt", col_names = FALSE) %>% setNames("ID") # PERU clade
FLS2 <- read_table("/path/to/FLS2.txt", col_names = FALSE) %>% setNames("ID") # FLS2 clade


# import the amplified seqeuences metadata (table S6)
hm_meta <- read_csv("/path/to/table S6.csv")
hm_meta$Species <- gsub("S.","Solanum", hm_meta$Species) # slight modifications to make it compatible with the rest of the data


## extract metadata and tidy it up

# PERU and homologs responsive/non-responsive
DM_hm_nr_meta <- SolDB_metadata[SolDB_metadata$ID %in% DM_hm_nr$ID,]
DM_hm_nr_meta <- DM_hm_nr %>% left_join(DM_hm_nr_meta, by = "ID")

DM_hm_nr_meta <- merge(DM_hm_nr_meta, hm_meta, by = "ID", all.x = TRUE) # add the species metadata of the responsive/non-responsive homologs
DM_hm_nr_meta$SciName <- coalesce(DM_hm_nr_meta$SciName.x, DM_hm_nr_meta$SciName.y) # clean up
DM_hm_nr_meta <- DM_hm_nr_meta[,-c(7,8)]

DM_hm_nr_meta <- DM_hm_nr %>% left_join(DM_hm_nr_meta, by = "ID") # reorder the based on the phylogenetic tree


# FLS2
FLS2_meta <- SolDB_metadata[SolDB_metadata$ID %in% FLS2$ID,]
FLS2_meta <- FLS2 %>% left_join(FLS2_meta, by = "ID") # reorder the based on the phylogenetic tree



# import the species list

species_list <- read_csv("/path/to/trees/species_list.txt", col_names = FALSE) %>% 
  setNames("species")

# import the organism list (genomes)

org_list <- read_csv("/path/to/trees/org_list.txt", col_names = FALSE) %>% 
  setNames("Organism")

```

-   producing presence/absence matrices

#### Per Species:

This code creates a binary data frame that indicates whether each sequence in the `DM_hm_nr_meta` data frame belongs to a particular species. The `species_list` data frame contains a list of species names. The code iterates over the rows of `species_list` and creates a logical vector that indicates whether the current sequence name matches the species name. The code then creates a column in the binary data frame for the current species name and populates the column with the values from the logical vector. The code then sets the row names of the binary data frame to the sequence names, removes the sequence name column, replaces all NA values with 0, and transposes the data frame. The resulting data frame can be used to identify the species of each sequence in the `DM_hm_nr_meta` data frame. This will be used to generate the presence/absence heatmap. The same code is also used to generate a similar binary data frame for FLS2 clade.

```{r}
library(tidyverse)

## PERU with responsive and non-responsive homologs

# create a data frame with the sequence names as the only column.
DM_hm_nr_binary_df <- data.frame(seqname = DM_hm_nr_meta$seqname)

# iterate over the rows of the species list.
for (i in 1:nrow(species_list)) {
  species <- species_list$species[i] # get the species name for the current row.
  matches <- ifelse(DM_hm_nr_meta$SciName == species, 1, 0) # create a logical vector that indicates whether the current sequence name matches the species name.
  colname <- paste0(species) # create a column in the binary data frame for the current species name.
  DM_hm_nr_binary_df[colname] <- matches
}

# set the row names of the binary data frame to the sequence names.
rownames(DM_hm_nr_binary_df) <- DM_hm_nr_binary_df$seqname 

# remove the sequence name column from the binary data frame.
DM_hm_nr_binary_df <- DM_hm_nr_binary_df[,-c(1)]

# replace all NA values in the binary data frame with 0.
DM_hm_nr_binary_df[is.na(DM_hm_nr_binary_df)] <- 0

# optional step: transpose the binary data frame and convert it back to a data frame. this changes the place of rows and columns.
tDM_hm_nr_binary_df <- t(DM_hm_nr_binary_df) %>% as.data.frame()
```

#### Per Genome:

The code below also creates a binary data frame that indicates whether each sequence in the `DM_hm_nr_meta` and `FLS2_meta` data frames belongs to a particular organism (genome) in `org_list`. The line-by-line annotation follows the previous script but this time based on organism names.

```{r}
library(tidyverse)
library(pheatmap)

# PERU
DM_hm_nr_org_binary_df <- data.frame(seqname = DM_hm_nr_meta$seqname)

for (i in 1:nrow(org_list)) {
  organism <- org_list$Organism[i]
  matches <- ifelse(DM_hm_nr_meta$Organism == organism, 1, 0)
  colname <- paste0(organism)
  DM_hm_nr_org_binary_df[colname] <- matches
}

rownames(DM_hm_nr_org_binary_df) <- DM_hm_nr_org_binary_df$seqname

DM_hm_nr_org_binary_df <- DM_hm_nr_org_binary_df[,-c(1)]

DM_hm_nr_org_binary_df[is.na(DM_hm_nr_org_binary_df)] <- 0


# FLS2
FLS2_org_binary_df <- data.frame(seqname = FLS2_meta$seqname)

for (i in 1:nrow(org_list)) {
  organism <- org_list$Organism[i]
  matches <- ifelse(FLS2_meta$Organism == organism, 1, 0)
  colname <- paste0(organism)
  FLS2_org_binary_df[colname] <- matches
}

rownames(FLS2_org_binary_df) <- FLS2_org_binary_df$seqname

FLS2_org_binary_df <- FLS2_org_binary_df[,-c(1)]

FLS2_org_binary_df[is.na(FLS2_org_binary_df)] <- 0

```

-   Generating the plots

#### Figure 4A:

The `pheatmap` function is used to create heatmaps. The resulting heatmaps shows the distribution of the binary values in the `DM_hm_nr_binary_df` data frame. The rows of the heatmaps represent the species in the data frame and the columns represent the sequences. The colors in the heatmaps represent the presence (dark grey) or absence (white) in the data frame.

```{r}
library(tidyverse)
library(pheatmap)

# custom color palette used for the plots
mypalette <- colorRampPalette(c("#F2F4F4","#424949"))


# PERU clade (fig 4A)
p_DM_hm_nr <- pheatmap(tDM_hm_nr_binary_df, # this transposed version of the binary dataframe allows to visualize the heatmap horizontally
                       cluster_rows = FALSE, cluster_cols = FALSE, 
                       show_colnames = TRUE, show_rownames = TRUE,
                       color = mypalette(2), 
                       border_color = "white", 
                       cellwidth = 10, cellheight = 10, # optional (as in Fig 4A)
                       gaps_row = (1:29)) # optional (as in Fig 4A)

ggsave(plot = p_DM_hm_nr, filename = "DM_hm_nr_pa.pdf",width = 35, height = 15, units = "in", dpi = "retina", device = "pdf", 
       path = "/path/to/your/directory/")
```

The following pieces of code also create the heatmaps used in figure S10, but instead of species it uses the organism names.

#### Figure S10A:

```{r}
library(tidyverse)
library(pheatmap)

p_DM_hm_nr_org <- pheatmap(DM_hm_nr_org_binary_df, 
                        cluster_rows = FALSE, cluster_cols = FALSE, 
                        show_colnames = TRUE, show_rownames = TRUE,
                        color = mypalette(2), 
                        border_color = "white", 
                        cellwidth = 10, cellheight = 10) # optional (as in fig S10A)

# optional: you can export the plot
ggsave(plot = p_DM_hm_nr_org, filename = "DM_hm_nr_pa_org.pdf",width = 25, height = 35, units = "in", dpi = "retina", device = "pdf", path = "/path/to/your/directory/")

```

#### Figure S10B:

```{r}
library(tidyverse)
library(pheatmap)

p_FLS2_org <- pheatmap(FLS2_org_binary_df, 
                     cluster_rows = FALSE, cluster_cols = FALSE, 
                     show_colnames = TRUE, show_rownames = TRUE,
                     color = mypalette(2), 
                     border_color = "white", cellwidth = 10, cellheight = 10)

# optional: you can export the plot
ggsave(plot = p_FLS2_org, filename = "FLS2_pa_org.pdf",width = 25, height = 25, units = "in", dpi = "retina", device = "pdf", 
       path = "/path/to/your/directory/")

```
